%%writefile matrix_multiblock_print.cu
#include <stdio.h>
#include <cuda_runtime.h>

#define N 100
#define BLOCK_SIZE 16

int A[N][N];
int B[N][N];
int C[N][N];

__device__ int dev_A[N*N];
__device__ int dev_B[N*N];
__device__ int dev_C[N*N];



__global__ void MatrixAdd() {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    int idx = y * N + x;
        dev_C[idx] = dev_A[idx] + dev_B[idx];
}

int main() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            A[i][j] = i + j;
            B[i][j] = i * j;
        }
    }


    cudaMemcpyToSymbol(dev_A, A, N*N*sizeof(int));
    cudaMemcpyToSymbol(dev_B, B, N*N*sizeof(int));


    dim3 threads(BLOCK_SIZE, BLOCK_SIZE);
    dim3 blocks((N + BLOCK_SIZE - 1) / BLOCK_SIZE, (N + BLOCK_SIZE - 1) / BLOCK_SIZE);


    MatrixAdd<<<blocks, threads>>>();
    cudaDeviceSynchronize();


    cudaMemcpyFromSymbol(C, dev_C, N*N*sizeof(int));


    bool ok = true;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (C[i][j] != A[i][j] + B[i][j])
                ok = false;

    if (ok)
        printf(" mátrixösszeadás helyes!\n\n");
    else
        printf(" hiba az eredményben!\n\n");


    printf("A mátrix (részlet):\n");
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 8; x++) {
            printf("%4d ", A[y][x]);
        }
        printf("\n");
    }
    printf("\n");

    printf("B mátrix (részlet):\n");
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 8; x++) {
            printf("%4d ", B[y][x]);
        }
        printf("\n");
    }
    printf("\n");

    printf("C = A + B mátrix (részlet):\n");
    for (int y = 0; y < 8; y++) {
        for (int x = 0; x < 8; x++) {
            printf("%4d ", C[y][x]);
        }
        printf("\n");
    }
    printf("\n");

    cudaDeviceReset();
    return 0;
}
